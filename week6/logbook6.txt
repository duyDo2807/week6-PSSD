GoodHours:
- Initial thoughts: At first when reading the rules of the problem, I get how Johnny likes some moments of the clock, but still don't get it when it comes to 2 moments beforeTime and afterTime, while we only need one string moment to calculate the good hour. But after reading the rules more carefully, I found out that we have to return the total moments of good hours between these two moments string inclusively, which is more complicated than normal. For this problem, at first, I thought of setting up each variable H1, H2, M1, M2 for saving time into the variables first (converting  string to integer) and a variable count to return the final result, then use 4 for-loops to iterate each digit. Through some calculations, we will increase the count by one through each loop if the condition is satisfied. After finishing all 4 loops, return the final result.
- Reflections: The output ran as I expected. But to ensure easy readings, I decide to convert to minutes directly for easy one for-loop and vice versa; and also included those functions into the private part of the code. The bool function to check calculations is also included in the private part to convert each hour and minute to interger and check if one of 3 calculations is correct and return true, else false. Overall, the code is now fairly easy to read and be implemented by others.
I got a bit of output errors due to forgetting when the minutes after are lower than the minutes before. But it is fixed now.

DerivativeSequence:
- Initial thoughts: The rules of the problem is very straightforward as it tells the user to calculate the difference between this position of digit and its next position of the digit and so on until the last and the second last digit; finally return the vector integer of the sequence after n operations of that subtraction. I also notice that the result vector will be shortened by n digits. To solve this problem at first, I thought of setting up some variables including the length of the vector and a vector result to return the result, using for-loop to iterate through the vector, at each position, calculate the differences from position 0 until we reach n - 2 position, and repeat that process n times.
- Reflections: The initial codes did some unexpected behaviors because of how I implemented it. So I decided to change my approach. This time, I try to not complicate the code just by implementing the initial vector current with vector a as its initial. Then I loop for n times, initate a temporary vector next each loop. Then I use another for loop inside iterating the current vector, pushing back the difference into the respective position of the next vector and setting the current vector as that next vector after finising the inner loop. After the outer loop, return the current vector.
