GoodHours:
- Initial thoughts: At first when reading the rules of the problem, I get how Johnny likes some moments of the clock, but still don't get it when it comes to 2 moments beforeTime and afterTime, while we only need one string moment to calculate the good hour. But after reading the rules more carefully, I found out that we have to return the total moments of good hours between these two moments string inclusively, which is more complicated than normal. For this problem, at first, I thought of setting up each variable H1, H2, M1, M2 for saving time into the variables first (converting  string to integer) and a variable count to return the final result, then use 4 for-loops to iterate each digit. Through some calculations, we will increase the count by one through each loop if the condition is satisfied. After finishing all 4 loops, return the final result.
- Reflections: The output ran as I expected. But to ensure easy readings, I decide to convert to minutes directly for easy one for-loop and vice versa; and also included those functions into the private part of the code. The bool function to check calculations is also included in the private part to convert each hour and minute to interger and check if one of 3 calculations is correct and return true, else false. Overall, the code is now fairly easy to read and be implemented by others.
I got a bit of output errors due to forgetting when the minutes after are lower than the minutes before. But it is fixed now.

DerivativeSequence:
- Initial thoughts: The rules of the problem is very straightforward as it tells the user to calculate the difference between this position of digit and its next position of the digit and so on until the last and the second last digit; finally return the vector integer of the sequence after n operations of that subtraction. I also notice that the result vector will be shortened by n digits. To solve this problem at first, I thought of setting up some variables including the length of the vector and a vector result to return the result, using for-loop to iterate through the vector, at each position, calculate the differences from position 0 until we reach n - 2 position, and repeat that process n times.
- Reflections: The initial codes did some unexpected behaviors because of how I implemented it. So I decided to change my approach. This time, I try to not complicate the code just by implementing the initial vector current with vector a as its initial. Then I loop for n times, initate a temporary vector next each loop. Then I use another for loop inside iterating the current vector, pushing back the difference into the respective position of the next vector and setting the current vector as that next vector after finising the inner loop. After the outer loop, return the current vector.

AlternateColors:
- Initial thoughts: The rules are fairly easy to understand as to repeat the procedure of destroying red green blue until it reaches the k-th ball and return that ball's color, also mind the cases when the number of one or two of the three types of balls run out. The implementation of the code might be fairly complicated as we hve to consider the cases mentioned above. At first, I thought of using a while-loop and a set up vector string to return the result. The while-loop reaches its end if all three balls run out. Inside the loop, there are three if-statement used to push RED, GREEN or BLUE into the result vector, and we finally return the k-1-th element of the vector.
- Reflections: Unfortunately, for the above approach, the autograder doesnt even wanna run. Maybe because the approach couldn't handle large numbers of balls. I decided to find other way. I swear the rules sound simple but not if we have to consider the large numbers. This time, the getColor function determines the color of the k-th ball to be destroyed from a collection of red, green, and blue balls. It first calculates how many complete cycles of red, green, and blue balls can be destroyed by finding the minimum count among the three colors. It then uses this to adjust the remaining count of balls and the index k. Based on the remaining counts, it calculates which color will be destroyed at the k-th position. The function handles various cases where the counts of balls are different and returns the color of the k-th ball.

BlackAndWhiteSolitaire:
- Initial thoughts: The problem told us to return the number of minium cards flipped in order to get the sequence which is one color is different from the next color. For this problem, I thought of using 2 for-loops for each Black and White with their respective flipNumber and return the minimum of the 2 result flipNumber1 and 2. For each loop, we check if the position is odd or even and also check if the letter is the same or different from the respective loop's color and increase the flipNum accordingly to it. Finally, we return the min result of the two variables flipNum.
- Reflections: The codes ran as I expected. No further fix needed to implement as the codes are minimalized to the most according to my perspective. Overall, everything looks fine to read and easy to understand.

ImportantTasks:
- Initial thoughts: The rules are pretty easy to understand, given the examples below. The problem tells us to return the number of tasks can be completed based on the number of computer and its according number and the task's number. To implement the codes for this problem, first, I will sort both vectors using built in function for easy managing first, so that each computer can commplete its respective task from min to max. Then I set up some variables: taskCount for returning the result; and i, j respective to each vector. Then I use a while vector, end until i or j reach the end of respective vectors. If the complexity of the task is smaller than the computer's, the counter will increase by one and the position of the next computer will be in place. The index of the vector complexity will increase in the while loop, no matter if there's no computer can run the task so that the loop can end. FInally, return the taskCount.
- Reflections: The code ran as I expected from the initial approach. Overall, the codes are the most minimalist for now as it provide easy reading and understanding for readers and users.
